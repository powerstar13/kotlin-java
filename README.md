# 자바 프로젝트에 코틀린 도입해보기

## 게터, 세터 호출하기

1. 자바에서 코틀린 프로퍼티를 호출할 때 게터, 세터를 사용한다.
2. val로 선언한 프로퍼티는 불변이기 때문에 게터만 존재한다.
3. 세터를 private 가시성으로 변경하면 var로 선언해도 세터를 없앨 수 있다.
4. `private set`으로 세터를 제거하면 내부에서만 변경하거나 외부 접근 함수를 별도로 만들어야 한다.
5. `@JvmField` 사용해서 코틀린 프로퍼티 접근
    1. 코틀린의 프로퍼티는 자바로 변환 시 필드는 private이고 게터, 세터를 통해서만 접근이 가능하다.
6. 코틀린에서 자바의 게터, 세터를 호출할 땐 기존 자바 스타일과 동일하게 쓸 수 있다.
    1. 코틀린 스타일대로 프로퍼티를 직접 사용할 수 있다. (추천)

## 코틀린의 예외처리와 자바 예약어 접근 방법

1. 자바에선 `체크드 익셉션`을 다룰 때 try-catch나 throws가 필수다.
2. 코틀린에는 `체크드 익셉션`이 존재하지 않음
   1. 그러므로 코틀린에서 IOException을 발생시키는 함수를 자바에서 사용해도 예외 처리가 강제되지 않는다.
   2. 자바 개발자는 이런코드에 대해 습관적으로 try-catch문으로 감싸곤한다.
      1. 그러나 예상과는 다르게 컴파일 에러가 발생한다.
      2. 자바를 생각해보면 `throws IOException`를 사용해서 발생 가능 예외에 대해 사용하는 측에 전달할 수 있다.
      3. 코틀린도 이와 마찬가지로 자바와의 상호 운용을 위한 `@Throws`를 제공한다.
         1. 자바 컴파일러가 체크드 익셉션을 인지해 컴파일 에러가 발생하지 않는다.
3. 자바와 상호운용하는 경우, 특정 변수명이 자바에선 문제가 없으나 코틀린에선 예약어인 경우가 있다.
   1. 예를 들어 관례적으로 많이 사용하는 `in`, `is`가 그렇다.
   2. 코틀린에서 바로 사용하면 컴파일 에러가 발생한다.
      1. 벡틱(```)문자를 사용해 해결할 수 있다.
         1. 이런기능은 별 필요 없어 보이지만 경우에 따라선 비즈니스와도 연결될 수 있다.
            1. 예를 들어 글로벌 서비스를 제공하는 회사에서 도미니카 공화국을 지원하기 위해 국가코드로 `do`를 사용하는데 do는 do-while문 예약어이다.
            2. 자바로는 처리가 어렵지만 코틀린은 예약어 이스케이프가 가능하기 때문에 도미니카 공화국도 서비스 제공가능

## @JvmStatic을 이용해 정직 함수 호출하기

1. 동반 객체와 object 키워드로 정의된 싱글톤 객체에서 정의된 함수를 코틀린에서 사용하면 자바의 static 메서드와 유사하게 사용할 수 있다.
2. `@JvmStatic`을 사용하면 자바의 static 메서드처럼 사용할 수 있다.
3. `const` 키워드를 사용한 상수는 자바의 static 프로퍼티처럼 직접 사용이 가능하다.
4. 상수가 아닌 경우에도 자바의 static 프로퍼티와 같이 사용하려면 `@JvmField`를 사용한다.

## 자바에서 확장함수 호출하기

1. 자바에서 사용할 땐 `파일명(클래스명).메서드명` 형태로 사용해야 한다.
2. 코틀린 확장함수가 변환된 static 메서드의 첫 번째 인자로 확장 대상 수신자 객체를 넘겨줘야하는 것을 알 수 있다.
3. 코틀린에선 마치 기존의 String 클래스에 존재하는 인스턴스 함수인 것처럼 사용하지만 자바에선 static 메서드로 호출해야 한다.

## 코틀린과 롬복

1. 코틀린에서 롬복 사용 시 발생하는 문제
   1. 롬복은 자바 진영에서 가장 많이 사용되는 라이브러리 중 하나로 애노테이션을 통해 생성자, 게터, 세터, 빌더 등을 자동으로 생성해준다.
   2. 그러나 코틀린과 자바를 상호 운용하는 경우, 롬복을 사용하면 정상 동작하지 않는다.
   3. 직접 만든 게터, 세터를 사용한 프로퍼티는 정상 동작한다.
2. 코틀린과 자바 통합 프로젝트에서 컴파일되는 과정
   - 가장 먼저 코틀린컴파일러가 코틀린 코드와 코틀린 코드에서 참조하는 자바 코드를 컴파일해서 바이트코드를 생성한다.
   - 그 다음 자바 컴파일러가 자바 코드를 컴파일하는데 이때 애노테이션 프로세싱 단계가 동작한다.
   - `애노테이션 프로세서(Annotation Processor)`는 컴파일 타임에 애노테이션을 읽어서 동적으로 코드를 생성하거나 변경하는 등의 기능을 말한다.
   - 이러한 컴파일 순서 이슈로 인해 기본적으로 롬복을 사용하지 못한다.
3. 일반적인 해결 방법
   1. IDE의 자동 생성 기능 사용
   2. 데이터 클래스로 마이그레이션
      1. 코틀린의 데이터 클래스로 마이그레이션하는 것을 추천
      2. **자바 프로젝트를 점진적으로 코틀린으로 전환하기 위해 이 방법을 제일 추천하고, 실무에서도 이 방법을 사용 중이다.**
   3. 이 외에도 코틀린에서 제공하는 롬복 플러그인을 사용할 수 있다.

## 자바 기반 스프링 프로젝트에 코틀린 적용

1. Gradle Kotlin DSL
   1. Gradle은 빌드 스크립트를 작성할 때 기본적으로Groovy 언어를 사용해 작성한다.
   2. 익숙하지 않은 Groovy 대신 Kotlin 기반으로 빌드 스크립트를 작성할 수 있다.
   3. Kotlin DSL로 Gradle 빌드 스크립트를 작성하면 IntelliJ, Android Studio와 같은 Jetbrains IDEA에서 코틀린 관련 지원을 받을 수 있다. (*자동완성, 컴파일 오류 체크 등*)
   4. Kotlin DSL로 작성한 빌드 스크립트는 `.kts` 확장자를 가진다.
      1. **KTS**: Kotlin Script의 약자이다.
   5. Kotlin DSL로 작성된 빌드 스크립트는 순수 Groovy로 작성한 빌드 스크립트보단 조금 느린 건 사실이지만 점점 개선되고 있다.
2. Spring 플러그인
   1. 코틀린의 클래스는 기본적으로 `final` 즉, 상속이 불가능한 클래스이다.
      1. 상속을 열어뒀을 때 발생하는 부작용으로 인해 코틀린은 상속이 꼭 필요한 경우에만 적용하도록 `open` 키워드를 사용해 상속을 허용하도록 지원한다.
   2. 문제는 스프링은 기본적으로 `CGLIB 프록시`를 사용해 애노테이션이 붙은 클래스에 대한 프록시 객체를 생성하는데, CGLIB 프록시는 대상 객체를 상속하여 프록시 객체를 생성한다.
      1. 코틀린의 클래스는 기본적으로 final이기 때문에 상속이 불가능해 프록시 객체를 생성할 수 없다.
   3. 매번 open 키워드를붙이는 건 불편하므로 코틀린은 `All-open` 컴파일러 플러그인을 제공한다.
      1. 매번 문제가 생길 때마다 allOpen에 추가하기 어려우므로 allOpen 플러그인을 래핑한 `kotlin-spring` 플러그인을 사용하면 매우 간편해진다.
      2. kotlin-spring 플러그인은 스프링에서 CGLIB 프록시를 사용하는 모든 애노테이션에 대해 자동으로 open 처리를 해준다.
         - `@Component`
         - `@Transactional`
         - `@Configuration`, `@Controller`, `@Service`, `@Repository` 등은 내부에 `@Component` 애노테이션을 메타-애노테이션으로 가지고 있다.
3. JPA 플러그인
   1. JPA에서 엔티티 클래스를 생성하려면 매개 변수가 없는 기본 생성자가 필요하다.
      1. 코틀린은 매개 변수가 없는 기본 생성자를 자동으로 만들어주는 `no-arg` 컴파일러 플러그인을 제공한다.
   2. JPA를 쓸 경우 Spring 플러그인과 마찬가지로 `kotlin-jpa` 플러그인을 제공한다.
      1. JPA 플러그인을 쓰면 `@Entity`, `@Embeddable`, `@MappedSuperclass`에 대한 기본 생성자를 자동으로 생성해준다.